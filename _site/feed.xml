

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>http://localhost:4000/</id>
  <title>ZLY-Blog</title>
  <subtitle>Something meaningless</subtitle>
  <updated>2024-03-23T18:47:40+08:00</updated>
  <author>
    <name>zly</name>
    <uri>http://localhost:4000/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="http://localhost:4000/"/>
  <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator>
  <rights> © 2024 zly </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>OSLAB</title>
    <link href="http://localhost:4000/posts/OSLAB-REVIEW/" rel="alternate" type="text/html" title="OSLAB" />
    <published>2024-02-17T00:00:00+08:00</published>
  
    <updated>2024-02-17T00:00:00+08:00</updated>
  
    <id>http://localhost:4000/posts/OSLAB-REVIEW/</id>
    <content src="http://localhost:4000/posts/OSLAB-REVIEW/" />
    <author>
      <name>zly</name>
    </author>

  
    
    <category term="OS" />
    
    <category term="REVIEW" />
    
  

  
    <summary>
      





      OSLAB总结

本校的OS实验搬来了XV6，并进行了一些改动，本文一是对OS实验过程的一个记录，二是对操作系统的一些机制进行简单梳理。

实验二 SYSCALL

第一个实验没有太多需要记录的，所以直接略过

顾名思义，本实验主要针对XV6中的系统调用设计。其中又涉及到对XV6进程的理解。

关于系统调用

系统调用其实就是一个操作系统给用户程序开放的访问内核空间的合法接口。用户程序需要访问内核空间的时候只需要


  提供系统调用号（存入EAX）
  触发软中断让系统进入内核空间


内核中的中断处理函数自动根据系统调用号调用对应的内核函数，内核函数将结果将返回值存入EAX，然后回到中断处理函数，最终回到用户空间，用户程序通过读取EAX得到结果

在这个过程中，我想最需要注意的就是系统调用所涉及的上下文切换：


  这里的上下文切换只是模式切换，与进程调度所涉及的上下文不同，我...
    </summary>
  

  </entry>

</feed>


