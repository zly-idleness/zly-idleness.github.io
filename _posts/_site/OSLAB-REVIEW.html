<h1 id="oslab总结">OSLAB总结</h1>

<p>本校的OS实验搬来了XV6，并进行了一些改动，本文一是对OS实验过程的一个记录，二是对操作系统的一些机制进行简单梳理。</p>

<h2 id="实验二-syscall">实验二 SYSCALL</h2>

<p>第一个实验没有太多需要记录的，所以直接略过</p>

<p>顾名思义，本实验主要针对XV6中的系统调用设计。其中又涉及到对XV6进程的理解。</p>

<h3 id="关于系统调用">关于系统调用</h3>

<p>系统调用其实就是一个操作系统给用户程序开放的访问内核空间的合法接口。用户程序需要访问内核空间的时候只需要</p>

<ul>
  <li>提供系统调用号（存入EAX）</li>
  <li>触发软中断让系统进入内核空间</li>
</ul>

<p>内核中的中断处理函数自动根据系统调用号调用对应的内核函数，内核函数将结果将返回值存入EAX，然后回到中断处理函数，最终回到用户空间，用户程序通过读取EAX得到结果</p>

<p>在这个过程中，我想最需要注意的就是系统调用所涉及的上下文切换：</p>

<ul>
  <li>这里的上下文切换只是模式切换，与进程调度所涉及的上下文不同，我们可以大致将上下文分成三部分
    <ul>
      <li>（1）用户级上下文: 正文、数据、用户堆栈以及共享存储区；</li>
      <li>（2）寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)；</li>
      <li>（3）系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、pte)、内核栈。</li>
    </ul>
  </li>
  <li>
    <p>系统调用主要进行进程寄存器上下文的切换。因此，相比进程调度负担少很多</p>
  </li>
  <li>这里摘录一段linux中断上下文的描述</li>
</ul>

<div class="language-md highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gs">**Interrupt Context**</span>

   When executing an interrupt handler or bottom half, the kernel is in interrupt context. Recall that process context is the mode of operation the kernel is in while it is executing on behalf of a process -- for example, executing a system  call or running a kernel thread. In process context, the current macro  points to the associated task. Furthermore, because a process is coupled to the kernel in process context(进程以进程上文的形式连接到内核中的), process context can sleep or otherwise invoke the scheduler.

   Interrupt context, on the other hand, is not associated with a process. The current macro is not relevant (although it points to the  interrupted process). Without a backing process(由于没有进程的背景),interrupt context cannot sleep -- how would it ever reschedule? Therefore, you cannot call certain functions from interrupt context. If a function sleeps, you cannot use it from your interrupt handler -- this limits  the functions that one can call from an interrupt  handler.(函数在中断处理程序中使用的限制)

   Interrupt context is time critical because the interrupt handler  interrupts other code. Code should be quick and simple. Busy looping is  discouraged. This is a very important point; always keep in mind that your interrupt handler has interrupted other code (possibly even another interrupt handler on a different line!). Because of this asynchronous nature, it is imperative(必须) that all interrupt  handlers be as quick and as simple as possible. As much as possible,  work should be pushed out from the interrupt handler and performed in a  bottom half, which runs at a more convenient time.

   The setup of an interrupt handler's stacks is a configuration option.  Historically, interrupt handlers did not receive their own stacks.  Instead, they would share the stack of the process that they  interrupted[1]. The kernel stack is two pages in size; typically, that  is 8KB on 32-bit architectures and 16KB on 64-bit architectures. Because in this setup interrupt handlers share the stack, they must be  exceptionally frugal with what data they allocate there. Of  course, the kernel stack is limited to begin with, so all kernel code  should be cautious.

  A process is always running. When nothing else is schedulable, the idle task runs. 

</code></pre></div></div>

<ul>
  <li>当然，因为切换了虚拟内存空间，用户空间的资源和内核空间的资源也是不互通的，需要通过特定的函数来实现资源拷贝，比如LINUX的COPY_TO_USER，COPY_FROM_USER 。</li>
</ul>

<h3 id="如何为我们的系统添加一个系统调用">如何为我们的系统添加一个系统调用</h3>

<p>在编译之前完成如下几件事即可</p>

<ul>
  <li>
    <p>注册系统调用（这里需要根据不同的硬件架构注册，因为软中断也需要硬件的信号触发，本校实验默认risc-v因此只需要在syscall.h声明即可，例如是x86 linux 则在”linux_src”/arch/x86/include/generated/asm/syscalls_64.h中）</p>
  </li>
  <li>
    <p>声明内核函数原型（一般在syscall.h)</p>
  </li>
  <li>
    <p>实现内核函数(sys.c(linux))</p>
  </li>
</ul>

<h3 id="实验具体">实验具体</h3>

<p>事实上实验指导书写的非常详细，相当于喂饭了，这里我只记录关于进程的一些重要内容：</p>

<p>首先来看看进程到底是个啥</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">proc</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">lock</span><span class="p">;</span>

  <span class="c1">// p-&gt;lock must be held when using these:</span>
  <span class="k">enum</span> <span class="n">procstate</span> <span class="n">state</span><span class="p">;</span>        <span class="c1">// Process state</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>         <span class="c1">// Parent process</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">chan</span><span class="p">;</span>                  <span class="c1">// If non-zero, sleeping on chan</span>
  <span class="kt">int</span> <span class="n">killed</span><span class="p">;</span>                  <span class="c1">// If non-zero, have been killed</span>
  <span class="kt">int</span> <span class="n">xstate</span><span class="p">;</span>                  <span class="c1">// Exit status to be returned to parent's wait</span>
  <span class="kt">int</span> <span class="n">pid</span><span class="p">;</span>                     <span class="c1">// Process ID</span>

  <span class="c1">// these are private to the process, so p-&gt;lock need not be held.</span>
  <span class="n">uint64</span> <span class="n">kstack</span><span class="p">;</span>               <span class="c1">// Virtual address of kernel stack</span>
  <span class="n">uint64</span> <span class="n">sz</span><span class="p">;</span>                   <span class="c1">// Size of process memory (bytes)</span>
  <span class="n">pagetable_t</span> <span class="n">pagetable</span><span class="p">;</span>       <span class="c1">// User page table</span>
  <span class="k">struct</span> <span class="n">trapframe</span> <span class="o">*</span><span class="n">trapframe</span><span class="p">;</span> <span class="c1">// data page for trampoline.S</span>
  <span class="k">struct</span> <span class="n">context</span> <span class="n">context</span><span class="p">;</span>      <span class="c1">// swtch() here to run process</span>
  <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span>  <span class="c1">// Open files</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">cwd</span><span class="p">;</span>           <span class="c1">// Current directory</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>               <span class="c1">// Process name (debugging)</span>
<span class="p">};</span>

</code></pre></div></div>

<p><del>这里贴心的给我们写出了什么时候要加锁，还不感谢proc.h</del></p>

<p>进程状态</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">SLEEPING</span> <span class="err">、</span> <span class="n">RUNNABLE</span> <span class="err">和</span> <span class="n">RUNNING</span> <span class="err">分别表示睡眠、阻塞和正在运行三个状态</span>
    <span class="n">UNUSED</span><span class="err">：在进程池中，尚未使用，还没有被分配出去；</span>
    <span class="n">USED</span><span class="err">：刚从进程池中分配出去，但是此时进程相关资源还没分配；</span>
    <span class="n">ZOMBIE</span><span class="err">：僵尸状态，当一个进程执行完成的时候，会调用</span> <span class="n">exit</span> <span class="err">退出，此时进程会进入这个状态，需要等待父进程调用</span> <span class="n">wait</span> <span class="err">来回收子进程所有剩下的资源；</span>

	<span class="err">当一个子进程执行</span> <span class="n">exit</span> <span class="err">退出，但是父进程一直没有调用</span> <span class="n">wait</span> <span class="err">来回收子进程的资源，这个时候这个子进程就被称为僵尸进程；</span>

	<span class="err">如果子进程退出之前，父进程就已经终止了，此时子进程还在运行，这个进程就称为孤儿进程，孤儿进程会被</span> <span class="n">init</span> <span class="err">进程所接管，最后会由</span> <span class="n">init</span> <span class="err">进程调用</span> <span class="n">wait</span> <span class="err">来释放资源；</span>
</code></pre></div></div>

<p>再看看fork时子进程是怎么创建的</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// Copy user memory from parent to child.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">uvmcopy</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">freeproc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">np</span><span class="o">-&gt;</span><span class="n">sz</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>

  <span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

  <span class="c1">// copy saved user registers.</span>
  <span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">);</span>

  <span class="c1">// Cause fork to return 0 in the child.</span>
  <span class="n">np</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// increment reference counts on open file descriptors.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NOFILE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">filedup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="n">np</span><span class="o">-&gt;</span><span class="n">cwd</span> <span class="o">=</span> <span class="n">idup</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>

  <span class="n">safestrcpy</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>

  <span class="n">pid</span> <span class="o">=</span> <span class="n">np</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>

  <span class="n">np</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">RUNNABLE</span><span class="p">;</span>
</code></pre></div></div>

<p>可以看到，子进程几乎是完全独立于父进程的，复制了父进程的寄存器数据，页表，但之后的寄存器数据和叶表变化都不会对父进程有影响，这里和线程就有很大的不同。也就是说，fork复制的大多是数据，而非指针，这就决定了二者的数据独立。当然由于只复制了文件描述符也导致父子进程对于文件是共享的。</p>

<p>剩下的具体实验内容就不多做阐述，跟着指导书的步骤直接写就行，这里写一个相对有趣问题的回答</p>

<p>为什么子进程（4、5、6号进程）的输出之前会 <strong>稳定的</strong> 出现一个<code class="language-plaintext highlighter-rouge">$</code>符号？（提示：shell程序(<code class="language-plaintext highlighter-rouge">sh.c</code>)中什么时候打印出<code class="language-plaintext highlighter-rouge">$</code>符号？）</p>

<p>父进程退出时，调用了wakeup1(original_parent)，而父进程的父进程是sh，sche（）后sh又执行了getcmd死循环因此会打印“$”</p>

<h2 id="实验三-lock">实验三 LOCK</h2>

<p>这个实验的主题是要解决优化锁争用，选的两个典型</p>

<ul>
  <li>kalloc中的自旋锁（中断关闭）</li>
  <li>bcache中的睡眠锁（允许yield和中断）</li>
</ul>

<p>实验实现也还是相对直接，甚至不涉及太多系统方面的知识，这里讲一讲对两个问题解决方案的异同点：</p>

<ul>
  <li>为什么这两种锁争用的优化方法会不同</li>
</ul>

<blockquote>
  <p>主要原因在我看来还是锁保护的资源性质不同所造成的问题，内存分配器所维护的归根结底是一条freelist，我们的优化方法只是相当于给每一个CPU单独分配了一个接口和区域限制去访问它，这个切分和数据是没有关系的，从不同接口访问所取得的资源本质上是没有差别的，kalloc也没有接受任何参数。而磁盘缓存分配则不同，不同blockno所对应的要取出的资源是不同的，也就是说，我们所面对的数据是需要有自己的标签来寻找的，那么要减少寻找的时间，简单的分割资源限制区域就行不通了，也就是说，这里对区域的分割也要和资源自身的标签相关，那么hash算法就成了自然的一种选择。</p>
</blockquote>

<ul>
  <li>当然，这里的并行也是在做区域的切分，因此kalloc中的steal策略在bcache中一样是适用的</li>
</ul>

<h2 id="实验四-页表">实验四 页表</h2>

<p>这个实验的主题是实现xv6的独立内核页表，不过我总感觉这个优化大概率只会产生负效果。</p>

<p>先来讨论一下，通过实现独立内核页表我们得到了什么吧。</p>

<p>虽然名字叫做独立内核页表，但寻其本质就是我们给每一个进程都额外储存了一份从内核地址空间到该进程用户地址空间的映射，因此我们可以方便地在内核态读取用户空间的资源，好像仅此一个优点。。。</p>

<p>但是为此，我们需要在每次中断上下文切换时，刷新掉宝贵的TLB，让原本cost极少的中断处理变得奢侈，CPU的缓存也需要刷新。我们的优化是为了方便内核函数执行，但执行内核函数必然要执行中断上下文切换，内核态本来就不应该过多读取用户态的数据，为了特殊情况牺牲最普遍情况的性能，只能说是出于教学目的的考虑了。</p>

<p>另外，这样的处理也造成了对资源的极大浪费，相当于我们的用户进程页表资源开销是之前的两倍（每个进程都储存了重复的内核地址索引和用户叶子页表索引）</p>

<p>还有一点就是安全问题，sync实现相当于将用户空间的数据搬到了内核空间中，而且没有也很难做任何安全性上的校验，及其容易产生系统漏洞。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="s">"Kernel Developers do not put blind faith in anything"</span><span class="p">.</span> <span class="n">When</span> <span class="n">any</span> <span class="n">data</span> <span class="n">is</span> <span class="n">passed</span> <span class="n">to</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">space</span> <span class="n">from</span> <span class="n">userspace</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">the</span> <span class="n">responsibility</span> <span class="n">of</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">developer</span> <span class="n">to</span> <span class="n">make</span> <span class="n">sure</span> <span class="n">that</span> <span class="n">everything</span> <span class="n">is</span> <span class="n">sanitized</span><span class="p">.</span> <span class="n">Just</span> <span class="n">as</span> <span class="n">you</span> <span class="n">check</span> <span class="k">for</span> <span class="n">corner</span> <span class="n">conditions</span> <span class="n">in</span> <span class="n">the</span> <span class="n">functions</span><span class="p">,</span> <span class="n">it</span> <span class="n">is</span> <span class="n">something</span> <span class="n">similar</span> <span class="k">for</span> <span class="n">the</span> <span class="n">kernel</span> <span class="n">developers</span><span class="p">.</span> <span class="n">Its</span> <span class="n">a</span> <span class="n">hygienic</span> <span class="n">practice</span> <span class="n">to</span> <span class="n">use</span> <span class="n">copy_from_user</span><span class="p">()</span> <span class="n">to</span> <span class="n">read</span> <span class="n">the</span> <span class="n">userspace</span> <span class="n">data</span><span class="p">.</span>
</code></pre></div></div>

<p>这里贴一下x86 linux copy_to_user的实现</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">_copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">might_fault</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">should_fail_usercopy</span><span class="p">())</span>
		<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">access_ok</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">instrument_copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">raw_copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">_copy_to_user</span><span class="p">);</span>


<span class="cm">/**
 * instrument_copy_to_user - instrument reads of copy_to_user
 * @to: destination address
 * @from: source address
 * @n: number of bytes to copy
 *
 * Instrument reads from kernel memory, that are due to copy_to_user (and
 * variants). The instrumentation must be inserted before the accesses.
 */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="kt">void</span>
<span class="nf">instrument_copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kasan_check_read</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">kcsan_check_read</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
	<span class="n">kmsan_copy_to_user</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">from</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">kmsan_copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">to_copy</span><span class="p">,</span>
			<span class="kt">size_t</span> <span class="n">left</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ua_flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kmsan_enabled</span> <span class="o">||</span> <span class="n">kmsan_in_runtime</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/*
	 * At this point we've copied the memory already. It's hard to check it
	 * before copying, as the size of actually copied buffer is unknown.
	 */</span>

	<span class="cm">/* copy_to_user() may copy zero bytes. No need to check. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">to_copy</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="cm">/* Or maybe copy_to_user() failed to copy anything. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_copy</span> <span class="o">&lt;=</span> <span class="n">left</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ua_flags</span> <span class="o">=</span> <span class="n">user_access_save</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">to</span> <span class="o">&lt;</span> <span class="n">TASK_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This is a user memory access, check it. */</span>
		<span class="n">kmsan_internal_check_memory</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span> <span class="n">to_copy</span> <span class="o">-</span> <span class="n">left</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span>
					    <span class="n">REASON_COPY_TO_USER</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Otherwise this is a kernel memory access. This happens when a
		 * compat syscall passes an argument allocated on the kernel
		 * stack to a real syscall.
		 * Don't check anything, just copy the shadow of the copied
		 * bytes.
		 */</span>
		<span class="n">kmsan_internal_memmove_metadata</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">to</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">from</span><span class="p">,</span>
						<span class="n">to_copy</span> <span class="o">-</span> <span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">user_access_restore</span><span class="p">(</span><span class="n">ua_flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmsan_copy_to_user</span><span class="p">);</span>


<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">__must_check</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">copy_user_generic</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">stac</span><span class="p">();</span>
	<span class="cm">/*
	 * If CPU has FSRM feature, use 'rep movs'.
	 * Otherwise, use rep_movs_alternative.
	 */</span>
	<span class="n">asm</span> <span class="k">volatile</span><span class="p">(</span>
		<span class="s">"1:</span><span class="se">\n\t</span><span class="s">"</span>
		<span class="n">ALTERNATIVE</span><span class="p">(</span><span class="s">"rep movsb"</span><span class="p">,</span>
			    <span class="s">"call rep_movs_alternative"</span><span class="p">,</span> <span class="n">ALT_NOT</span><span class="p">(</span><span class="n">X86_FEATURE_FSRM</span><span class="p">))</span>
		<span class="s">"2:</span><span class="se">\n</span><span class="s">"</span>
		<span class="n">_ASM_EXTABLE_UA</span><span class="p">(</span><span class="mi">1</span><span class="n">b</span><span class="p">,</span> <span class="mi">2</span><span class="n">b</span><span class="p">)</span>
		<span class="o">:</span><span class="s">"+c"</span> <span class="p">(</span><span class="n">len</span><span class="p">),</span> <span class="s">"+D"</span> <span class="p">(</span><span class="n">to</span><span class="p">),</span> <span class="s">"+S"</span> <span class="p">(</span><span class="n">from</span><span class="p">),</span> <span class="n">ASM_CALL_CONSTRAINT</span>
		<span class="o">:</span> <span class="o">:</span> <span class="s">"memory"</span><span class="p">,</span> <span class="s">"rax"</span><span class="p">);</span>
	<span class="n">clac</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">__must_check</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="nf">raw_copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">copy_user_generic</span><span class="p">((</span><span class="n">__force</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>

</code></pre></div></div>

<p>众所周知，LINUX是使用共享内核页表的，当碰到copy_to/from_user性能成为瓶颈时，LINUX选择使用mmap实现连续高效的物理内存共享，我想这会是更好的解决方案。</p>

<p>具体实验内容指导书写的差不多了，因此不多赘述，借此实验，我想可以研究一下x86 linux的进程页表机制,以下内容参考了此博客<a href="https://www.cnblogs.com/binlovetech/p/17571929.html">Linux 页表体系 —— 详解虚拟内存如何与物理内存进行映射</a></p>

<p>这篇文章中最关键的点是说明了内核页表，内核线程，用户虚拟内存空间这三者的关系，</p>

<hr />

<p>处于内核态的进程以及内核线程来说并不能直接访问全局内核页表，它们只能访问内核页表的 copy 副本（事实上也在进程页表中，所以内核所操作的内核页表天然就是独立的），进程的页表分为两个部分，一个是进程用户态页表，另一个就是内核页表的 copy 部分。</p>

<p>fork 系统调用在创建子进程的时候，会拷贝父进程的所有资源，当拷贝父进程的虚拟内存空间的时候，内核会通过  pgd_alloc 函数为子进程创建顶级页表 pgd，在 pgd_alloc 函数中还会调用 pgd_ctor，这个 pgd_ctor 函数会将内核页表拷贝到进程页表中。</p>

<hr />

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">mm_struct</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">vm_area_struct</span>  <span class="o">*</span><span class="n">mmap</span><span class="p">;</span>               <span class="cm">/* list of memory areas */</span>
        <span class="k">struct</span> <span class="n">rb_root</span>         <span class="n">mm_rb</span><span class="p">;</span>               <span class="cm">/* red-black tree of VMAs */</span>
        <span class="k">struct</span> <span class="n">vm_area_struct</span>  <span class="o">*</span><span class="n">mmap_cache</span><span class="p">;</span>         <span class="cm">/* last used memory area */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">free_area_cache</span><span class="p">;</span>     <span class="cm">/* 1st address space hole */</span>
        <span class="n">pgd_t</span>                  <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>                <span class="cm">/* page global directory */</span>
        <span class="n">atomic_t</span>               <span class="n">mm_users</span><span class="p">;</span>            <span class="cm">/* address space users */</span>
        <span class="n">atomic_t</span>               <span class="n">mm_count</span><span class="p">;</span>            <span class="cm">/* primary usage counter */</span>
        <span class="kt">int</span>                    <span class="n">map_count</span><span class="p">;</span>           <span class="cm">/* number of memory areas */</span>
        <span class="k">struct</span> <span class="n">rw_semaphore</span>    <span class="n">mmap_sem</span><span class="p">;</span>            <span class="cm">/* memory area semaphore */</span>
        <span class="n">spinlock_t</span>             <span class="n">page_table_lock</span><span class="p">;</span>     <span class="cm">/* page table lock */</span>
        <span class="k">struct</span> <span class="n">list_head</span>       <span class="n">mmlist</span><span class="p">;</span>              <span class="cm">/* list of all mm_structs */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">start_code</span><span class="p">;</span>          <span class="cm">/* start address of code */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">end_code</span><span class="p">;</span>            <span class="cm">/* final address of code */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">start_data</span><span class="p">;</span>          <span class="cm">/* start address of data */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">end_data</span><span class="p">;</span>            <span class="cm">/* final address of data */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">start_brk</span><span class="p">;</span>           <span class="cm">/* start address of heap */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">brk</span><span class="p">;</span>                 <span class="cm">/* final address of heap */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">start_stack</span><span class="p">;</span>         <span class="cm">/* start address of stack */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">arg_start</span><span class="p">;</span>           <span class="cm">/* start of arguments */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">arg_end</span><span class="p">;</span>             <span class="cm">/* end of arguments */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">env_start</span><span class="p">;</span>           <span class="cm">/* start of environment */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">env_end</span><span class="p">;</span>             <span class="cm">/* end of environment */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">rss</span><span class="p">;</span>                 <span class="cm">/* pages allocated */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">total_vm</span><span class="p">;</span>            <span class="cm">/* total number of pages */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">locked_vm</span><span class="p">;</span>           <span class="cm">/* number of locked pages */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">def_flags</span><span class="p">;</span>           <span class="cm">/* default access flags */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">cpu_vm_mask</span><span class="p">;</span>         <span class="cm">/* lazy TLB switch mask */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span>          <span class="n">swap_address</span><span class="p">;</span>        <span class="cm">/* last scanned address */</span>
        <span class="kt">unsigned</span>               <span class="n">dumpable</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>          <span class="cm">/* can this mm core dump? */</span>
        <span class="kt">int</span>                    <span class="n">used_hugetlb</span><span class="p">;</span>        <span class="cm">/* used hugetlb pages? */</span>
        <span class="n">mm_context_t</span>           <span class="n">context</span><span class="p">;</span>             <span class="cm">/* arch-specific data */</span>
        <span class="kt">int</span>                    <span class="n">core_waiters</span><span class="p">;</span>        <span class="cm">/* thread core dump waiters */</span>
        <span class="k">struct</span> <span class="n">completion</span>      <span class="o">*</span><span class="n">core_startup_done</span><span class="p">;</span>  <span class="cm">/* core start completion */</span>
        <span class="k">struct</span> <span class="n">completion</span>      <span class="n">core_done</span><span class="p">;</span>           <span class="cm">/* core end completion */</span>
        <span class="n">rwlock_t</span>               <span class="n">ioctx_list_lock</span><span class="p">;</span>     <span class="cm">/* AIO I/O list lock */</span>
        <span class="k">struct</span> <span class="n">kioctx</span>          <span class="o">*</span><span class="n">ioctx_list</span><span class="p">;</span>         <span class="cm">/* AIO I/O list */</span>
        <span class="k">struct</span> <span class="n">kioctx</span>          <span class="n">default_kioctx</span><span class="p">;</span>      <span class="cm">/* AIO default I/O context */</span>
<span class="p">};</span>
</code></pre></div></div>

<blockquote>
  <p>进程的虚拟内存空间在内核中是用 struct mm_struct  结构来描述的，每个进程都有自己独立的虚拟内存空间，而进程的虚拟内存到物理内存的映射也是独立的，为了保证每个进程里内存映射的独立进行，所以每个进程都会有独立的页表，而页表的起始地址就存放在 struct mm_struct 结构中的 pgd 属性中。</p>
</blockquote>

<blockquote>
  <p>当我们使用 fork 系统调用创建进程的时候，内核在 _do_fork 函数中会通过 copy_process 将父进程的所有资源拷贝到子进程中，这其中也包括父进程的虚拟内存空间。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">_do_fork</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_start</span><span class="p">,</span>
       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">parent_tidptr</span><span class="p">,</span>
       <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidptr</span><span class="p">,</span>
       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tls</span><span class="p">)</span>
<span class="p">{</span>
              <span class="p">.........</span>  <span class="p">..........</span>
     <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

              <span class="p">.........</span>  <span class="p">..........</span>
    <span class="c1">// 拷贝父进程的所有资源</span>
     <span class="n">p</span> <span class="o">=</span> <span class="n">copy_process</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">stack_start</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">,</span>
         <span class="n">child_tidptr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">tls</span><span class="p">,</span> <span class="n">NUMA_NO_NODE</span><span class="p">);</span>

             <span class="p">.........</span>  <span class="p">..........</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__latent_entropy</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="nf">copy_process</span><span class="p">(</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_start</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_size</span><span class="p">,</span>
     <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">child_tidptr</span><span class="p">,</span>
     <span class="k">struct</span> <span class="n">pid</span> <span class="o">*</span><span class="n">pid</span><span class="p">,</span>
     <span class="kt">int</span> <span class="n">trace</span><span class="p">,</span>
     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">tls</span><span class="p">,</span>
     <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="c1">// 为进程创建 task_struct 结构</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">dup_task_struct</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>

        <span class="p">.......</span> <span class="err">初始化子进程</span> <span class="p">...........</span>

        <span class="p">.......</span> <span class="err">开始拷贝父进程资源</span>  <span class="p">.......</span>      

    <span class="c1">// 拷贝父进程的虚拟内存空间以及页表</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">copy_mm</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>

        <span class="p">.........</span> <span class="err">拷贝父进程的其他资源</span> <span class="p">.........</span>

    <span class="c1">// 分配 CPU</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="n">sched_fork</span><span class="p">(</span><span class="n">clone_flags</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="c1">// 分配 pid</span>
    <span class="n">pid</span> <span class="o">=</span> <span class="n">alloc_pid</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nsproxy</span><span class="o">-&gt;</span><span class="n">pid_ns_for_children</span><span class="p">);</span>

        <span class="p">...........</span>  <span class="p">.........</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>copy_mm 函数负责处理子进程虚拟内存空间的初始化工作，它会调用 dup_mm 函数，最终在 dup_mm 函数中将父进程虚拟内存空间的所有内容包括父进程的相关页表全部拷贝到子进程中，其中就包括了为子进程分配顶级页表起始地址 pgd。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">copy_mm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">clone_flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">......</span>  <span class="p">........</span>
    
    <span class="n">mm</span> <span class="o">=</span> <span class="n">dup_mm</span><span class="p">(</span><span class="n">tsk</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
    
    <span class="p">......</span>  <span class="p">........</span>
<span class="p">}</span>

<span class="cm">/**
 * Allocates a new mm structure and duplicates the provided @oldmm structure
 * content into it.
 */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">dup_mm</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span><span class="p">)</span>
<span class="p">{</span>
     <span class="c1">// 子进程虚拟内存空间，此时还是空的</span>
     <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
     <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
     <span class="c1">// 为子进程申请 mm_struct 结构</span>
     <span class="n">mm</span> <span class="o">=</span> <span class="n">allocate_mm</span><span class="p">();</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
     <span class="c1">// 将父进程 mm_struct 结构里的内容全部拷贝到子进程 mm_struct 结构中</span>
     <span class="n">memcpy</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mm</span><span class="p">));</span>
     <span class="c1">// 为子进程分配顶级页表起始地址并赋值给 mm_struct-&gt;pgd</span>
     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mm_init</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">tsk</span><span class="p">,</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fail_nomem</span><span class="p">;</span>
     <span class="c1">// 拷贝父进程的虚拟内存空间中的内容以及页表到子进程中</span>
     <span class="n">err</span> <span class="o">=</span> <span class="n">dup_mmap</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">oldmm</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">free_pt</span><span class="p">;</span>

     <span class="k">return</span> <span class="n">mm</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>最后内核会在 mm_init 函数中调用 mm_alloc_pgd，并在 mm_alloc_pgd 函数中通过调用 pgd_alloc 为子进程分配其独立的顶级页表起始地址，赋值给子进程 struct mm_struct 结构中的 pgd 属性。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="nf">mm_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">user_namespace</span> <span class="o">*</span><span class="n">user_ns</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">....</span> <span class="err">初始化子进程的</span> <span class="n">mm_struct</span> <span class="err">结构</span> <span class="p">......</span>
    
    <span class="c1">// 为子进程分配顶级页表起始地址 pgd</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">mm_alloc_pgd</span><span class="p">(</span><span class="n">mm</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">fail_nopgd</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_alloc_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 内核为子进程分配好其顶级页表起始地址之后</span>
    <span class="c1">// 赋值给子进程 mm_struct 结构中的 pgd 属性</span>
    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>进程上下文进行切换内容主要包括：1.进程虚拟内存空间的切换。2.寄存器以及进程栈的切换。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * context_switch - switch to the new MM and the new thread's register state.
 */</span>
<span class="k">static</span> <span class="n">__always_inline</span> <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span>
<span class="nf">context_switch</span><span class="p">(</span><span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
           <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_flags</span> <span class="o">*</span><span class="n">rf</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">........</span>  <span class="p">,,,,,,,,,,</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">)</span> <span class="p">{</span>                                <span class="c1">// to kernel</span>

        <span class="p">........</span> <span class="err">内核线程的切换</span> <span class="p">,,,,,,,,,,</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>                                        <span class="c1">// to user</span>
        <span class="p">........</span> <span class="err">用户进程的切换</span> <span class="p">,,,,,,,,,,</span>

        <span class="n">membarrier_switch_mm</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
        <span class="c1">// 切换进程虚拟内存空间</span>
        <span class="n">switch_mm_irqs_off</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 切换 CPU 上下文和进程栈</span>
    <span class="n">switch_to</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="n">barrier</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">finish_task_switch</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>switch_mm_irqs_off 函数负责对进程虚拟内存空间进行切换，其中就包括了调用 load_new_mm_cr3 函数将进程顶级页表起始地址 mm_struct-&gt; pgd 中的虚拟内存地址转换为物理内存地址，并将 pgd 的物理内存地址加载到 cr3 寄存器中。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">switch_mm_irqs_off</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
      <span class="c1">// 通过 __sme_pa 将 pgd 的虚拟内存地址转换为物理内存地址</span>
      <span class="c1">// 并加载到 cr3 寄存器中</span>
      <span class="n">load_new_mm_cr3</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">,</span> <span class="n">new_asid</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>cr3 寄存器中存放的是当前进程顶级页表 pgd 的物理内存地址，不能是虚拟内存地址。</p>
</blockquote>

<blockquote>
  <p>进程的上下文在内核中完成切换之后，现在 cr3 寄存器中保存的就是当前进程顶级页表的起始物理内存地址了，当 CPU  通过下图所示的虚拟内存地址访问进程的虚拟内存时，CPU 首先会从 cr3  寄存器中获取到当前进程的顶级页表起始地址，然后从虚拟内存地址中提取出虚拟内存页对应 PTE 在页表内的偏移，通过 页表起始地址 + 页表内偏移 * sizeof(PTE) 这个公式定位到虚拟内存页在页表中所对应的 PTE。而虚拟内存页背后所映射的物理内存页的起始地址就保存在该 PTE  中，随后 CPU 继续从上图所示的虚拟内存地址中提取后半部分——物理内存页内偏移，并通过 物理内存页起始地址 + 物理内存页内偏移就定位到了该物理内存页中一个具体的物理字节上。</p>
</blockquote>

<blockquote>
  <p><strong>对于处于内核态的进程以及内核线程来说并不能直接访问内核页表</strong>，它们只能访问内核页表的 copy <strong>副本</strong>，进程的页表分为两个部分，一个是进程用户态页表，另一个就是内核页表的 copy 部分。在 pgd_alloc 函数中还会调用 pgd_ctor，这个 pgd_ctor 函数的主要工作就是将内核页表拷贝到进程页表中。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">mm_alloc_pgd</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 内核为子进程分配好其顶级页表起始地址之后</span>
    <span class="c1">// 赋值给子进程 mm_struct 结构中的 pgd 属性</span>
    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd_alloc</span><span class="p">(</span><span class="n">mm</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span><span class="p">))</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">pgd_t</span> <span class="o">*</span><span class="nf">pgd_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pgd_t</span> <span class="o">*</span><span class="n">pgd</span><span class="p">;</span>
    <span class="c1">// 为子进程分配顶级页表</span>
    <span class="n">pgd</span> <span class="o">=</span> <span class="n">_pgd_alloc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pgd</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">pgd</span> <span class="o">=</span> <span class="n">pgd</span><span class="p">;</span>

    <span class="p">......</span> <span class="err">根据配置，与初始化子进程页表</span> <span class="p">.....</span>
    <span class="c1">// 拷贝内核页表到子进程中</span>
    <span class="n">pgd_ctor</span><span class="p">(</span><span class="n">mm</span><span class="p">,</span> <span class="n">pgd</span><span class="p">);</span>

    <span class="p">.......</span> <span class="err">省略</span> <span class="p">........</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>当进程通过系统调用切入到内核态之后，就会使用内核页表的这部分 copy  副本，来访问内核空间虚拟内存映射的物理内存。当进程页表中内核部分的拷贝副本与主内核页表不同步时，进程在内核态就会发生缺页中断，随后会同步主内核页表到进程页表中，这里又是延时拷贝在内核中的一处应用。</p>
</blockquote>

<blockquote>
  <p>内核线程有一点和普通的进程不同，内核线程只能运行在内核态，而在内核态中，所有进程看到的虚拟内存空间全部都是一样的，所以对于内核线程来说并不需要为其单独的定义 mm_struct 结构来描述内核虚拟内存空间，内核线程的 struct task_struct 结构中的 mm 属性指向  null，内核线程之间调度是不涉及地址空间切换的，从而避免了无用的 TLB 缓存以及 CPU 高速缓存的刷新。</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="c1">// 对于内核线程来说，它并没有自己的地址空间</span>
    <span class="c1">// 因为它始终工作在内核空间中，所有进程看到的都是一样的</span>
    <span class="k">struct</span> <span class="n">mm_struct</span>  <span class="o">*</span><span class="n">mm</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>但是内核线程依然需要访问内核空间中的虚拟内存，也就是说内核线程仍然需要内核页表，但是它又没有自己的地址空间,因此当一个内核线程被调度时，它会发现自己的虚拟地址空间为  null，虽然它不会访问用户态的内存，但是它会访问内核内存，聪明的内核会将调度之前的上一个用户态进程的虚拟内存空间 mm_struct  直接赋值给内核线程 task_struct-&gt;active_mm 中 。</p>
</blockquote>

<h2 id="实验五-fs">实验五 FS</h2>

<p>由于本人对文件系统了解不多，兴趣一般，就是按着指导书的逻辑随便抄抄改改simplefs的代码，这里就不做记录了。</p>

